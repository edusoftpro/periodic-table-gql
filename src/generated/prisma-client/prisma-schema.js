module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateDiscoverer {
  count: Int!
}

type AggregateElement {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Discoverer {
  id: Int!
  firstName: String
  lastName: String
  elements(where: ElementWhereInput, orderBy: ElementOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Element!]
}

type DiscovererConnection {
  pageInfo: PageInfo!
  edges: [DiscovererEdge]!
  aggregate: AggregateDiscoverer!
}

input DiscovererCreateInput {
  id: Int
  firstName: String
  lastName: String
  elements: ElementCreateManyWithoutDiscovererInput
}

input DiscovererCreateOneWithoutElementsInput {
  create: DiscovererCreateWithoutElementsInput
  connect: DiscovererWhereUniqueInput
}

input DiscovererCreateWithoutElementsInput {
  id: Int
  firstName: String
  lastName: String
}

type DiscovererEdge {
  node: Discoverer!
  cursor: String!
}

enum DiscovererOrderByInput {
  id_ASC
  id_DESC
  firstName_ASC
  firstName_DESC
  lastName_ASC
  lastName_DESC
}

type DiscovererPreviousValues {
  id: Int!
  firstName: String
  lastName: String
}

type DiscovererSubscriptionPayload {
  mutation: MutationType!
  node: Discoverer
  updatedFields: [String!]
  previousValues: DiscovererPreviousValues
}

input DiscovererSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: DiscovererWhereInput
  AND: [DiscovererSubscriptionWhereInput!]
  OR: [DiscovererSubscriptionWhereInput!]
  NOT: [DiscovererSubscriptionWhereInput!]
}

input DiscovererUpdateInput {
  firstName: String
  lastName: String
  elements: ElementUpdateManyWithoutDiscovererInput
}

input DiscovererUpdateManyMutationInput {
  firstName: String
  lastName: String
}

input DiscovererUpdateOneWithoutElementsInput {
  create: DiscovererCreateWithoutElementsInput
  update: DiscovererUpdateWithoutElementsDataInput
  upsert: DiscovererUpsertWithoutElementsInput
  delete: Boolean
  disconnect: Boolean
  connect: DiscovererWhereUniqueInput
}

input DiscovererUpdateWithoutElementsDataInput {
  firstName: String
  lastName: String
}

input DiscovererUpsertWithoutElementsInput {
  update: DiscovererUpdateWithoutElementsDataInput!
  create: DiscovererCreateWithoutElementsInput!
}

input DiscovererWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  firstName: String
  firstName_not: String
  firstName_in: [String!]
  firstName_not_in: [String!]
  firstName_lt: String
  firstName_lte: String
  firstName_gt: String
  firstName_gte: String
  firstName_contains: String
  firstName_not_contains: String
  firstName_starts_with: String
  firstName_not_starts_with: String
  firstName_ends_with: String
  firstName_not_ends_with: String
  lastName: String
  lastName_not: String
  lastName_in: [String!]
  lastName_not_in: [String!]
  lastName_lt: String
  lastName_lte: String
  lastName_gt: String
  lastName_gte: String
  lastName_contains: String
  lastName_not_contains: String
  lastName_starts_with: String
  lastName_not_starts_with: String
  lastName_ends_with: String
  lastName_not_ends_with: String
  elements_every: ElementWhereInput
  elements_some: ElementWhereInput
  elements_none: ElementWhereInput
  AND: [DiscovererWhereInput!]
  OR: [DiscovererWhereInput!]
  NOT: [DiscovererWhereInput!]
}

input DiscovererWhereUniqueInput {
  id: Int
}

type Element {
  id: Int!
  discoverer: Discoverer
  atomicNumber: Int!
  atomicMass: Float!
  symbol: String!
  name: String!
}

type ElementConnection {
  pageInfo: PageInfo!
  edges: [ElementEdge]!
  aggregate: AggregateElement!
}

input ElementCreateInput {
  id: Int
  discoverer: DiscovererCreateOneWithoutElementsInput
  atomicNumber: Int!
  atomicMass: Float!
  symbol: String!
  name: String!
}

input ElementCreateManyWithoutDiscovererInput {
  create: [ElementCreateWithoutDiscovererInput!]
  connect: [ElementWhereUniqueInput!]
}

input ElementCreateWithoutDiscovererInput {
  id: Int
  atomicNumber: Int!
  atomicMass: Float!
  symbol: String!
  name: String!
}

type ElementEdge {
  node: Element!
  cursor: String!
}

enum ElementOrderByInput {
  id_ASC
  id_DESC
  atomicNumber_ASC
  atomicNumber_DESC
  atomicMass_ASC
  atomicMass_DESC
  symbol_ASC
  symbol_DESC
  name_ASC
  name_DESC
}

type ElementPreviousValues {
  id: Int!
  atomicNumber: Int!
  atomicMass: Float!
  symbol: String!
  name: String!
}

input ElementScalarWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  atomicNumber: Int
  atomicNumber_not: Int
  atomicNumber_in: [Int!]
  atomicNumber_not_in: [Int!]
  atomicNumber_lt: Int
  atomicNumber_lte: Int
  atomicNumber_gt: Int
  atomicNumber_gte: Int
  atomicMass: Float
  atomicMass_not: Float
  atomicMass_in: [Float!]
  atomicMass_not_in: [Float!]
  atomicMass_lt: Float
  atomicMass_lte: Float
  atomicMass_gt: Float
  atomicMass_gte: Float
  symbol: String
  symbol_not: String
  symbol_in: [String!]
  symbol_not_in: [String!]
  symbol_lt: String
  symbol_lte: String
  symbol_gt: String
  symbol_gte: String
  symbol_contains: String
  symbol_not_contains: String
  symbol_starts_with: String
  symbol_not_starts_with: String
  symbol_ends_with: String
  symbol_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [ElementScalarWhereInput!]
  OR: [ElementScalarWhereInput!]
  NOT: [ElementScalarWhereInput!]
}

type ElementSubscriptionPayload {
  mutation: MutationType!
  node: Element
  updatedFields: [String!]
  previousValues: ElementPreviousValues
}

input ElementSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ElementWhereInput
  AND: [ElementSubscriptionWhereInput!]
  OR: [ElementSubscriptionWhereInput!]
  NOT: [ElementSubscriptionWhereInput!]
}

input ElementUpdateInput {
  discoverer: DiscovererUpdateOneWithoutElementsInput
  atomicNumber: Int
  atomicMass: Float
  symbol: String
  name: String
}

input ElementUpdateManyDataInput {
  atomicNumber: Int
  atomicMass: Float
  symbol: String
  name: String
}

input ElementUpdateManyMutationInput {
  atomicNumber: Int
  atomicMass: Float
  symbol: String
  name: String
}

input ElementUpdateManyWithoutDiscovererInput {
  create: [ElementCreateWithoutDiscovererInput!]
  delete: [ElementWhereUniqueInput!]
  connect: [ElementWhereUniqueInput!]
  set: [ElementWhereUniqueInput!]
  disconnect: [ElementWhereUniqueInput!]
  update: [ElementUpdateWithWhereUniqueWithoutDiscovererInput!]
  upsert: [ElementUpsertWithWhereUniqueWithoutDiscovererInput!]
  deleteMany: [ElementScalarWhereInput!]
  updateMany: [ElementUpdateManyWithWhereNestedInput!]
}

input ElementUpdateManyWithWhereNestedInput {
  where: ElementScalarWhereInput!
  data: ElementUpdateManyDataInput!
}

input ElementUpdateWithoutDiscovererDataInput {
  atomicNumber: Int
  atomicMass: Float
  symbol: String
  name: String
}

input ElementUpdateWithWhereUniqueWithoutDiscovererInput {
  where: ElementWhereUniqueInput!
  data: ElementUpdateWithoutDiscovererDataInput!
}

input ElementUpsertWithWhereUniqueWithoutDiscovererInput {
  where: ElementWhereUniqueInput!
  update: ElementUpdateWithoutDiscovererDataInput!
  create: ElementCreateWithoutDiscovererInput!
}

input ElementWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  discoverer: DiscovererWhereInput
  atomicNumber: Int
  atomicNumber_not: Int
  atomicNumber_in: [Int!]
  atomicNumber_not_in: [Int!]
  atomicNumber_lt: Int
  atomicNumber_lte: Int
  atomicNumber_gt: Int
  atomicNumber_gte: Int
  atomicMass: Float
  atomicMass_not: Float
  atomicMass_in: [Float!]
  atomicMass_not_in: [Float!]
  atomicMass_lt: Float
  atomicMass_lte: Float
  atomicMass_gt: Float
  atomicMass_gte: Float
  symbol: String
  symbol_not: String
  symbol_in: [String!]
  symbol_not_in: [String!]
  symbol_lt: String
  symbol_lte: String
  symbol_gt: String
  symbol_gte: String
  symbol_contains: String
  symbol_not_contains: String
  symbol_starts_with: String
  symbol_not_starts_with: String
  symbol_ends_with: String
  symbol_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [ElementWhereInput!]
  OR: [ElementWhereInput!]
  NOT: [ElementWhereInput!]
}

input ElementWhereUniqueInput {
  id: Int
}

scalar Long

type Mutation {
  createDiscoverer(data: DiscovererCreateInput!): Discoverer!
  updateDiscoverer(data: DiscovererUpdateInput!, where: DiscovererWhereUniqueInput!): Discoverer
  updateManyDiscoverers(data: DiscovererUpdateManyMutationInput!, where: DiscovererWhereInput): BatchPayload!
  upsertDiscoverer(where: DiscovererWhereUniqueInput!, create: DiscovererCreateInput!, update: DiscovererUpdateInput!): Discoverer!
  deleteDiscoverer(where: DiscovererWhereUniqueInput!): Discoverer
  deleteManyDiscoverers(where: DiscovererWhereInput): BatchPayload!
  createElement(data: ElementCreateInput!): Element!
  updateElement(data: ElementUpdateInput!, where: ElementWhereUniqueInput!): Element
  updateManyElements(data: ElementUpdateManyMutationInput!, where: ElementWhereInput): BatchPayload!
  upsertElement(where: ElementWhereUniqueInput!, create: ElementCreateInput!, update: ElementUpdateInput!): Element!
  deleteElement(where: ElementWhereUniqueInput!): Element
  deleteManyElements(where: ElementWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  discoverer(where: DiscovererWhereUniqueInput!): Discoverer
  discoverers(where: DiscovererWhereInput, orderBy: DiscovererOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Discoverer]!
  discoverersConnection(where: DiscovererWhereInput, orderBy: DiscovererOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): DiscovererConnection!
  element(where: ElementWhereUniqueInput!): Element
  elements(where: ElementWhereInput, orderBy: ElementOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Element]!
  elementsConnection(where: ElementWhereInput, orderBy: ElementOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ElementConnection!
  node(id: ID!): Node
}

type Subscription {
  discoverer(where: DiscovererSubscriptionWhereInput): DiscovererSubscriptionPayload
  element(where: ElementSubscriptionWhereInput): ElementSubscriptionPayload
}
`
      }
    